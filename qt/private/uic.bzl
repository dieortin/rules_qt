"""Rules that allow to use [Qt's uic](https://doc.qt.io/qt-5/uic.html) with Bazel."""

load(":private/utils.bzl", "QT_TOOLCHAIN")

def _uic_impl(ctx):
    toolchain = ctx.toolchains[QT_TOOLCHAIN]

    hdrs = list()
    includes = list()
    for src in ctx.files.srcs:
        hdr = ctx.actions.declare_file("ui_{name}.h".format(name = src.basename.rstrip("." + src.extension)))
        hdrs.append(hdr)
        includes.append(hdr.dirname)

        args = ctx.actions.args()
        args.add("--output", hdr)
        args.add(src)

        ctx.actions.run(
            inputs = [src],
            outputs = [hdr],
            progress_message = "[Qt uic]: generating {path}".format(path = hdr.short_path),
            executable = toolchain.qtinfo.uic,
            arguments = [args],
        )

    compilation_context = cc_common.create_compilation_context(
        includes = depset(includes),
        headers = depset(hdrs),
    )

    # We need to fill `includes` to keep compatibility with Qt
    # on how autogenerated files get included:
    # - Qt uses quote include style relative to current folder
    # - while Bazel requires to be more explicit with include paths
    #   and uses full paths relative to a project's root (WORKSPACE).
    return [CcInfo(compilation_context = compilation_context)]

uic = rule(
    implementation = _uic_impl,
    doc = """
Invokes `uic` on a given set of UI forms and exposes generated C++ headers
to be further used in downstream `cc_*` rules as compile time dependency,
i.e. to the `deps` attribute of `cc_*` riles.
""",
    attrs = {
        "srcs": attr.label_list(
            allow_files = [".ui"],
            mandatory = True,
            doc = """
A list of `.ui` forms.
""",
        ),
    },
    toolchains = [QT_TOOLCHAIN],
)
